#r "nuget:FSharp.Data"
#r "nuget:NodaTime"
#r "nuget: FSharp.Stats"
#r "nuget: Plotly.NET, 2.0.0-beta9"
#r "nuget: Accord"
#r "nuget: Accord.Statistics"
#r "nuget: FSharp.Stats, 0.4.1"

open Accord
open Accord.Statistics.Models.Regression.Linear
open System
open FSharp.Data
open NodaTime
open Plotly.NET
open FSharp.Stats
open Plotly.NET 
open Plotly.NET.StyleParam
fsi.AddPrinter<DateTime>(fun dt -> dt.ToString("s"))
fsi.AddPrinter<YearMonth>(fun ym -> $"{ym.Year}-{ym.Month}")
// set working directory to script directory
Environment.CurrentDirectory <- __SOURCE_DIRECTORY__
(**
## First, make sure that you're referencing the correct files.

Here I'm assuming that
I have a folder called `Project` inside my class folder and
that the `Project` folder is where this code that I am working
on is.

For example, a folder hierarchy like below where you
have the below files and folders accessible:
```
/class
    Common.fsx
    /data-cache
        id_and_return_data.csv
        rmax1_21d.csv
    /Project
        examplePortfolio.fsx
        examplePortfolio.ipynb
        Portfolio-3.fsx
```

### We will use the portfolio module
Make sure that you load this code
*)
#load "Portfolio-3.fsx"
open Portfolio
(**
### We will use the Common.fsx file
Make sure that this loads correctly.
*)
#load "../Common.fsx"
open Common
(**
### We need to reference the data
This script assumes the data .csv files  are in the data-cache folder
that is one level above the folder we're working in.

*)
let [<Literal>] dataCache = __SOURCE_DIRECTORY__ + "/../data-cache/"
let [<Literal>] idAndReturnsFile = dataCache + "id_and_return_data.csv"
let [<Literal>] mySignalFile = dataCache + "rmax1_21d.csv"
(**
If my paths are correct, then this code should read the first few lines of the files.
If it doesn't show the first few lines, fix the above file paths.
*)
IO.File.ReadAllLines(idAndReturnsFile) |> Seq.truncate 3

IO.File.ReadAllLines(mySignalFile) |> Seq.truncate 3
(**
## Now we're making the momentum code match this new dataset.
Define types for the main ID+Return dataset and your signal dataset.
*)
type IdAndReturnCsv = CsvProvider<Sample=idAndReturnsFile,
                                  // Override some column types that I forgot to make boolean
                                  // for easier use when doing filtering.
                                  // If I didn't do this overriding the columns would have strings
                                  // of "1" or "0", but explicit boolean is nicer.
                                  Schema="obsMain(string)->obsMain=bool,exchMain(string)->exchMain=bool",
                                  ResolutionFolder= __SOURCE_DIRECTORY__>

type Signal = CsvProvider<Sample=mySignalFile,
                          ResolutionFolder= __SOURCE_DIRECTORY__>
(**
Load your data. 

It can be interesting to plot your data

*)
let idAndReturns = IdAndReturnCsv.Load(idAndReturnsFile)
let mySignal = Signal.Load(mySignalFile)
mySignal
(**
This data is already cleaned, but in general it's always useful
to see what the data looks like.

There are lots of observations, so I'm going to sample it
before plotting.
*)
let rand = new Random()

let signalDistribution =
    mySignal.Rows
    |> Seq.choose(fun x -> x.Signal)
    // rand.NextDouble() generates a random floating point number
    // between 0 and 1.
    // Here I'm iterating through the sequence and on each iteration
    // I'm generating a random number that I'll use to sort the sequence.
    // It's like Seq.sortBy(fun x -> x.Symbol) but instead of sorting by
    // whatever x.Symbol gives you I'm sorting by whatever
    //  rand.NextDouble() gives you.
    |> Seq.sortBy(fun _ -> rand.NextDouble()) 
    |> Seq.truncate 1_000 
    |> Seq.toArray

let histogram =
    signalDistribution
    |> Chart.Histogram
histogram |> Chart.Show

(**
Let's index the data by security id and month.

- In this dataset, we'll use `row.Id` as the identifier. We'll assign it to
the `Other` SecurityId case, because it's a dataset specific one.
- In this dataset, the Eom variable defines the "end of month".
- The returns are for the month ending in EOM.
- The signals are "known" as of EOM. So you can use them on/after EOM. We'll
form portfolios in the month ending EOM; that's the `FormationMonth`.
*)
let msfBySecurityIdAndMonth =
    idAndReturns.Rows
    |> Seq.map(fun row -> 
        let index = Other row.Id, YearMonth(row.Eom.Year,row.Eom.Month)
        index, row)
    |> Map.ofSeq    

let signalBySecurityIdAndMonth =
    mySignal.Rows
    |> Seq.choose(fun row -> 
        // we'll use Seq.choose to drop the security if the security is missing. 
        match row.Signal with
        | None -> None // choose will drop these None observations
        | Some signal ->
            let index = Other row.Id, YearMonth(row.Eom.Year,row.Eom.Month)
            Some (index, signal) // choose will convert Some(index,signal) into
                                 // (index,signal) and keep that.
    )
    |> Map.ofSeq    
(**
The `securitiesByFormationMonth` that we'll use to define our investment universe.

*)
let securitiesByFormationMonth =
    idAndReturns.Rows
    |> Seq.groupBy(fun x -> YearMonth(x.Eom.Year, x.Eom.Month))
    |> Seq.map(fun (ym, xs) -> 
        ym, 
        xs 
        |> Seq.map(fun x -> Other x.Id) 
        |> Seq.toArray)
    |> Map.ofSeq

let getInvestmentUniverse formationMonth =
    match Map.tryFind formationMonth securitiesByFormationMonth with
    | Some securities -> 
        { FormationMonth = formationMonth 
          Securities = securities }
    | None -> failwith $"{formationMonth} is not in the date range"      
(**
Now I want to be able to get my signal.
*)
let getMySignal (securityId, formationMonth) =
    match Map.tryFind (securityId, formationMonth) signalBySecurityIdAndMonth with
    | None -> None
    | Some signal ->
        Some { SecurityId = securityId; Signal = signal }

let getMySignals (investmentUniverse: InvestmentUniverse) =
    let arrayOfSecuritySignals =
        investmentUniverse.Securities
        |> Array.choose(fun security -> 
            getMySignal (security, investmentUniverse.FormationMonth))    
    
    { FormationMonth = investmentUniverse.FormationMonth 
      Signals = arrayOfSecuritySignals }
(**
And I should be able to get my market capitalization
*)
let getMarketCap (security, formationMonth) =
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> None
    | Some row -> 
        match row.MarketEquity with
        | None -> None
        | Some me -> Some (security, me)
(**
And I should be able to get my returns.
*)
let getSecurityReturn (security, formationMonth) =
    // If the security has a missing return, assume that we got 0.0.
    // Note: If we were doing excess returns, we wouldd need 0.0 - rf.
    let missingReturn = 0.0
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> security, missingReturn
    | Some x ->  
        match x.Ret with 
        | None -> security, missingReturn
        | Some r -> security, r
 
getSecurityReturn (Other "comp_001111_02",YearMonth(2008,7))
//test the None 
getSecurityReturn (Other "comp_001111_01",YearMonth(2008,7))
getSecurityReturn (Other "comp_001111_02",YearMonth(1998,7))


//Also to get the security excess return

let getSecurityExcReturn (security, formationMonth) =
    let missingReturn = 0.0
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> security, missingReturn
    | Some x ->  
        match x.RetExc with 
        | None -> security, missingReturn
        | Some r -> security, r
(**
And we should do a few restrictions. These come from the data documentation
section 1.2, "How to use the data". These are some basic ones.
*)
let isObsMain (security, formationMonth) =
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> false
    | Some row -> row.ObsMain

let isPrimarySecurity (security, formationMonth) =
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> false
    | Some row -> row.PrimarySec

let isCommonStock (security, formationMonth) =
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> false
    | Some row -> row.Common

let isExchMain (security, formationMonth) =
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> false
    | Some row -> row.ExchMain

let hasMarketEquity (security, formationMonth) =
    match Map.tryFind (security, formationMonth) msfBySecurityIdAndMonth with
    | None -> false
    | Some row -> row.MarketEquity.IsSome

let myFilters securityAndFormationMonth =
    isObsMain securityAndFormationMonth &&
    isPrimarySecurity securityAndFormationMonth &&
    isCommonStock securityAndFormationMonth &&
    isExchMain securityAndFormationMonth &&
    isExchMain securityAndFormationMonth &&
    hasMarketEquity securityAndFormationMonth


let doMyFilters (universe:InvestmentUniverse) =
    let filtered = 
        universe.Securities
        // my filters expect security, formationMonth
        |> Array.map(fun security -> security, universe.FormationMonth)
        // do the filters
        |> Array.filter myFilters
        // now convert back from security, formationMonth -> security
        |> Array.map fst
    { universe with Securities = filtered }
(**
Define sample months
*)
let start_Sample = 
    idAndReturns.Rows
    |> Seq.map(fun row -> YearMonth(row.Eom.Year,row.Eom.Month))
    |> Seq.min

let end_Sample = 
    idAndReturns.Rows
    |> Seq.map(fun row -> YearMonth(row.Eom.Year,row.Eom.Month))
    |> Seq.max
    // The end of sample is the last month when we have returns.
    // So the last month when we can form portfolios is one month
    // before that.
    |> fun maxMonth -> maxMonth.PlusMonths(-1) 

let sampleMonths = 
    getSampleMonths (start_Sample, end_Sample)
    |> List.toArray
(**
Strategy function
*)
//Now I will create a function to form my strategy and test it
let formStrategy ym =
    ym
    |> getInvestmentUniverse
    |> doMyFilters
    |> getMySignals
    |> assignSignalSort "Mine" 3
    |> Array.map (giveValueWeights getMarketCap)
    |> Array.map (getPortfolioReturn getSecurityReturn)  
(**
Your strategy portfolios 
*)
let portfolios =
    sampleMonths
    |> Array.Parallel.collect formStrategy
(**
Common.fsx has some easy to use code to get Fama-French factors.
We're going to use the French data to get monthly risk-free rates.
*)
let ff3 = French.getFF3 Frequency.Monthly
let monthlyRiskFreeRate =
    ff3
    |> Array.map(fun x -> YearMonth(x.Date.Year,x.Date.Month),x.Rf)
    |> Map.ofArray
(**
Now I'll convert my portfolios into excess returns.
*)
let portfolioExcessReturns =
    portfolios
    |> Array.Parallel.map(fun x -> 
        match Map.tryFind x.YearMonth monthlyRiskFreeRate with 
        | None -> failwith $"Can't find risk-free rate for {x.YearMonth}"
        | Some rf -> { x with Return = x.Return - rf })
portfolioExcessReturns
(**
Let's plot the top portfolio
*)
let top =
    portfolioExcessReturns
    |> Array.filter(fun port ->
        port.PortfolioId = Indexed("Mine", 1))

let middle =
    portfolioExcessReturns
    |> Array.filter(fun port ->
        port.PortfolioId = Indexed("Mine", 2))
    
let bottom =
    portfolioExcessReturns
    |> Array.filter(fun port ->
        port.PortfolioId = Indexed("Mine", 3))
    
let cumulateReturn (xs: PortfolioReturn array) =
    let mapper (priorRet:float) (thisObservation:PortfolioReturn) =
        let asOfNow = priorRet*(1.0 + thisObservation.Return)
        { thisObservation with Return = asOfNow}, asOfNow
    // remember to make sure that your sort order is correct.
    let sorted = xs |> Array.sortBy(fun x -> x.YearMonth)
    (1.0, sorted) 
    ||> Array.mapFold mapper 
    |> fst      

let Cumulative x = 
    x 
    |> cumulateReturn


(**
Plotly.NET doesn't know about YearMonth, so I will convert to DateTime before plotting.
*)
let CumulativeChart xs =
    xs
    |> Array.map(fun x -> DateTime(x.YearMonth.Year,x.YearMonth.Month,1), x.Return)
    |> Chart.Line  
    |> Chart.withTitle "Growth of 1 Euro"  
//CumulativeChart |> Chart.Show 
(*
Long And Short strategy. For that,
I will go long on my Top Portfolio (top) and Short on my Bottom Portfolio(bottom)
*)

let LONG = 
    top
    |> Array.map (fun x -> { PortfolioId = Named "Long_Portfolio" ; 
                             YearMonth = x.YearMonth ;
                             Return = x.Return })

let SHORT = 
    bottom
    |> Array.map (fun x -> { PortfolioId = Named "Short_Portfolio" ; 
                             YearMonth = x.YearMonth ;
                             Return = -(x.Return) })
(*
Long-Short portfolio
*)
let longShort_Portfolio =
    let shortMap = SHORT |> Seq.map(fun row -> row.YearMonth, row) |> Map
    LONG
    |> Seq.map(fun longObs -> 
        match Map.tryFind longObs.YearMonth shortMap with
        | None -> failwith "probably your date variables are not aligned"
        | Some shortObs -> { PortfolioId = Named "Long-Short portfolio" ; 
                                YearMonth = longObs.YearMonth ;
                                Return = longObs.Return + shortObs.Return })
    |> Seq.toArray


(*
Value weighted MktRf
*)

let valueweightedMktRf =
    let portfolioMonths = portfolioExcessReturns |> Array.map(fun x -> x.YearMonth)
    let minYm = portfolioMonths |> Array.min
    let maxYm = portfolioMonths |> Array.max

    ff3
    |> Array.map(fun x -> 
        { PortfolioId = Named("Mkt-Rf")
          YearMonth = YearMonth(x.Date.Year,x.Date.Month)
          Return = x.MktRf })
    |> Array.filter(fun x -> 
        x.YearMonth >= minYm &&
        x.YearMonth <= maxYm)

let LONGCumulateReturn=Cumulative LONG
let LONGSHORTCumulateReturn=Cumulative longShort_Portfolio
let valueweightedCumulateReturn=Cumulative valueweightedMktRf

CumulativeChart (LONGCumulateReturn) |> Chart.withTitle "Long Only Portfolio" |> Chart.Show
CumulativeChart (LONGSHORTCumulateReturn) |> Chart.withTitle "Long-Short Portfolio" |> Chart.Show
CumulativeChart (valueweightedCumulateReturn) |> Chart.withTitle "Value Weighted Rf Portfolio" |> Chart.Show

(* 
(LONG Only; LONG-SHORT and MKT Risk free)
*)

let portfolioReturnPlot (xs:PortfolioReturn array) =
    xs
    |> Array.map(fun x -> DateTime(x.YearMonth.Year,x.YearMonth.Month,1), x.Return)
    |> Chart.Line 

(**
We could create one normalized to have 10\% annualized volatility
for the entire period. This isn't dynamic rebalancing. We're
just making the whole time-series have 10% vol.
*)

let long10_Vol (y:float)  =
    let topAnnualizedVol = sqrt(12.0) * (LONG |> Seq.stDevBy(fun x -> x.Return))
    LONG 
    |> Array.map(fun x -> { x with Return = (y/topAnnualizedVol) * x.Return })

let long_short10_Vol (y:float)  =
    let topAnnualizedVol = sqrt(12.0) * (longShort_Portfolio |> Seq.stDevBy(fun x -> x.Return))
    longShort_Portfolio 
    |> Array.map(fun x -> { x with Return = (y/topAnnualizedVol) * x.Return })

let MktRF10_Vol (y:float)  =
    let topAnnualizedVol = sqrt(12.0) * (valueweightedMktRf|> Seq.stDevBy(fun x -> x.Return))
    valueweightedMktRf
    |> Array.map(fun x -> { x with Return = (y/topAnnualizedVol) * x.Return })

let short10P_Vol (y:float)  =
    let topAnnualizedVol = sqrt(12.0) * (SHORT|> Seq.stDevBy(fun x -> x.Return))
    SHORT
    |> Array.map(fun x -> { x with Return = (y/topAnnualizedVol) * x.Return })

(**
We could write a function to do the vol normalization. 
*)
let normalizeToTenPct (xs:PortfolioReturn array) =
    let annualizedVol = sqrt(12.0) * (xs |> Seq.stDevBy(fun x -> x.Return))
    xs 
    |> Array.map(fun x -> 
        { x with Return = (0.1/annualizedVol) * x.Return })

let combinedChartWithoutVol =
    Array.concat [SHORT;LONG;longShort_Portfolio;valueweightedMktRf]
    |> Array.groupBy(fun x -> x.PortfolioId)
    |> Array.map(fun (portId, xs) ->
        xs
        |> cumulateReturn
        |> portfolioReturnPlot
        |> Chart.withTitle "Growth of 1 Euro without Volatility Target"
        |> Chart.withTraceName (portId.ToString()))
    |> Chart.Combine
    |> Chart.Show 

let combinedChartWith10Vol =
    Array.concat [short10P_Vol 0.1;long_short10_Vol 0.1;long_short10_Vol 0.1;MktRF10_Vol 0.1]
    |> Array.groupBy(fun x -> x.PortfolioId)
    |> Array.map(fun (portId, xs) ->
        xs
        |> cumulateReturn
        |> portfolioReturnPlot
        |> Chart.withTitle "Growth of 1 Euro with 10% volatility target"
        |> Chart.withTraceName (portId.ToString()))
    |> Chart.Combine
    |> Chart.Show 


(**
You might also want to save your results to a csv file.
*)
type PortfolioReturnCsv = CsvProvider<"portfolioName(string),index(int option),yearMonth(date),ret(float)">

let makePortfolioReturnCsvRow (row:PortfolioReturn) =
    let name, index =
        match row.PortfolioId with
        | Indexed(name, index) -> name, Some index
        | Named(name) -> name, None
    PortfolioReturnCsv
        .Row(portfolioName=name,
             index = index,
             yearMonth=DateTime(row.YearMonth.Year,row.YearMonth.Month,1),
             ret=row.Return)

portfolioExcessReturns
|> Array.map makePortfolioReturnCsvRow
|> fun rows -> 
    let csv = new PortfolioReturnCsv(rows)
    csv.Save("my_ExcessReturnPortfolios.csv")
(**
# Performance evaluation table
– Create a table to report performance measures for your portfolios for
the first half of the sample, the second half, and the full period. For
each period report:

*)

let half = longShort_Portfolio.Length/2
let xt, yt = longShort_Portfolio|> Array.splitAt half 
let HALF = xt |> Array.map ( fun x -> x.YearMonth) |> Array.last
(*
    second_half
*)
let second_half (xi:string) (xs :PortfolioReturn array) = 
    xs
    |> Array.map (fun x -> { PortfolioId = Named $"{xi} Portfolio" ; 
                             YearMonth = x.YearMonth ;
                             Return = x.Return })                       
    |> Array.filter(fun x -> 
        x.YearMonth >= HALF &&
        x.YearMonth <= end_Sample)

(*
returns during the first half of the sample for each portfolio (top/middle/bottom)
*)
let ret_LONGSecondHalf = second_half "Longportfolio" LONG

let ret_LONGSHORTSecondHalf = second_half "LongShortPortfolio" longShort_Portfolio

let ret_VWMktRfFirstHalf = second_half "FirstHalf Value-Weighted" valueweightedMktRf
(*
    first_half sample
*)

let first_half (xi:string) (xs :PortfolioReturn array) = 
    xs
    |> Array.map (fun x -> { PortfolioId = Named $"{xi} Portfolio" ; 
                             YearMonth = x.YearMonth ;
                             Return = x.Return })                       
    |> Array.filter(fun x -> 
        x.YearMonth >= start_Sample &&
        x.YearMonth < HALF)

(*
returns during the first half of the sample for each portfolio (top/middle/bottom)
*)

let ret_LONGFirstHalf = first_half "FirstHalfLONG" LONG

let ret_LONGSHORTFirstHalf = first_half "FirstHalf LONG & Short" longShort_Portfolio

let ret_VWMktRfSecondHalf = first_half "ValueWeightedPortfolio" valueweightedMktRf

(*
    calculating the annualized return
*)

let monthly_average_excess_ret (x : PortfolioReturn array) =
    x
    |> Array.averageBy ( fun x -> x.Return)
let annualized_return (x) = (monthly_average_excess_ret x)*(12.0)


let monthly_Vol ( xs : PortfolioReturn array) = 
    xs 
    |> Array.map ( fun x -> x.Return)
    |> Seq.stDev
let annualized_Vol x = (monthly_Vol x)* (sqrt (12.0))

(*
    Sharpe Ratio function
*)
let Sharpe_Ratio x = ( annualized_return x) / (annualized_Vol x )

(*
    table
*)
//first half
let FirstHalf_Header = ["LONG Return";"LS Return";"MktRf Return";"LONG SR";"LS SR";"MktRf SR"]
let FirstHalf_Rows = 
    [
     [ round 5 (annualized_return ret_LONGFirstHalf);
       round 5 (annualized_return ret_LONGSHORTFirstHalf);
       round 5 (annualized_return ret_VWMktRfFirstHalf)
       round 5 (Sharpe_Ratio ret_LONGFirstHalf);  
       round 5 (Sharpe_Ratio ret_LONGSHORTFirstHalf) ;
       round 5 (Sharpe_Ratio ret_VWMktRfFirstHalf) ]        
    ]

let Table_retFirstHalf = Chart.Table(FirstHalf_Header, FirstHalf_Rows) 
Table_retFirstHalf|> Chart.withTitle "First Half Sample Annualized Returns / Sharpe Ratio" |> Chart.Show

//second half
let SecondHalfheader = ["LONG Return";"LS Return";"MktRf Return";"LONG SR";"LS SR";"MktRf SR"]
let SecondHalfrows = 
    [
     [ round 5 (annualized_return ret_LONGSecondHalf);
       round 5 (annualized_return ret_LONGSHORTSecondHalf);
       round 5 (annualized_return ret_VWMktRfSecondHalf)
       round 5 (Sharpe_Ratio ret_LONGSecondHalf); 
       round 5 (Sharpe_Ratio ret_LONGSHORTSecondHalf) ; 
       round 5 (Sharpe_Ratio ret_VWMktRfSecondHalf) ]        
    ]

let TableSecondHalfReturns = Chart.Table(SecondHalfheader, SecondHalfrows) 
TableSecondHalfReturns|> Chart.withTitle "Second Half Sample Annualized Returns / Sharpe Ratio" |> Chart.Show

(**
full period
*)

let Header = ["LONG Return";"LS Return";"MktRf Return";"LONG SR";"LS SR";"MktRf SR"]
let Rows = 
    [
     [ round 5 (annualized_return LONG);
       round 5 (annualized_return longShort_Portfolio);
       round 5 (annualized_return valueweightedMktRf)
       round 5 (Sharpe_Ratio LONG);  
       round 5 (Sharpe_Ratio longShort_Portfolio) ; 
       round 5 (Sharpe_Ratio valueweightedMktRf) ]        
    ]
let TableReturns = Chart.Table(Header, Rows) 
TableReturns|> Chart.withTitle "Sample Annualized Returns / Sharpe Ratio" |> Chart.Show

(*CAPM and Fama and French alphas and t-statistics*)

(**
For regression, it is helpful to have the portfolio
return data merged into our factor model data.
*)

type RegData =
    { Date : DateTime
      Portfolio : float
      MktRf : float 
      Hml : float 
      Smb : float }

// ff3 indexed by month
// We're not doing date arithmetic, so I'll just
// use DateTime on the 1st of the month to represent a month
let ff3ByMonth = 
    ff3
    |> Array.map(fun x -> DateTime(x.Date.Year, x.Date.Month,1), x)
    |> Map

let reg_LONG =
    LONG
    |> Array.map(fun port ->
        let monthToFind = DateTime(port.YearMonth.Year,port.YearMonth.Month,1)
        match Map.tryFind monthToFind ff3ByMonth with
        | None -> failwith "probably you messed up your days of months"
        | Some ff3 -> 
            { Date = monthToFind
              Portfolio = port.Return 
              MktRf = ff3.MktRf 
              Hml = ff3.Hml 
              Smb = ff3.Smb })

let reg_LONGSHORT=
    longShort_Portfolio
    |> Array.map(fun port ->
        let monthToFind = DateTime(port.YearMonth.Year,port.YearMonth.Month,1)
        match Map.tryFind monthToFind ff3ByMonth with
        | None -> failwith "probably you messed up your days of months"
        | Some ff3 -> 
            { Date = monthToFind
              Portfolio = port.Return 
              MktRf = ff3.MktRf 
              Hml = ff3.Hml 
              Smb = ff3.Smb })

(**
OLS
https://github.com/accord-net/framework/wiki/Regression)

*)

type RegressionOutput =
    { Model : MultipleLinearRegression 
      TValuesWeights : float array
      TValuesIntercept : float }


type XY = (float array) array * float array

let fitModel (data: XY) =
    let x, y = data
    let ols = new OrdinaryLeastSquares(UseIntercept=true)
    let estimate = ols.Learn(x,y)
    let mse = estimate.GetStandardError(x,y)
    let se = estimate.GetStandardErrors(mse, ols.GetInformationMatrix())
    let tvaluesWeights = 
        estimate.Weights
        |> Array.mapi(fun i w -> w / se.[i])
    let tvalueIntercept = estimate.Intercept / (se |> Array.last)
    { Model = estimate
      TValuesWeights = tvaluesWeights
      TValuesIntercept = tvalueIntercept }

let capmModel_LONG = 
    reg_LONG
    |> Array.map(fun obs -> [|obs.MktRf|], obs.Portfolio)
    |> Array.unzip 

let capmModel_LONGSHORT = 
    reg_LONGSHORT
    |> Array.map(fun obs -> [|obs.MktRf|], obs.Portfolio)
    |> Array.unzip 

let ff3Model_LONG = 
    reg_LONG
    |> Array.map(fun obs -> [|obs.MktRf; obs.Hml; obs.Smb |], obs.Portfolio)
    |> Array.unzip

let ff3Model_LONGSHORT = 
    reg_LONGSHORT
    |> Array.map(fun obs -> [|obs.MktRf; obs.Hml; obs.Smb |], obs.Portfolio)
    |> Array.unzip

let r2Of (estimatedModel:MultipleLinearRegression) data =
    let x, y = data
    estimatedModel.CoefficientOfDetermination(x,y)
(**
Now we can estimate our models.
*)

let capmEstimate_LONG = capmModel_LONG |> fitModel
let capmEstimate_LONGSHORT = capmModel_LONGSHORT |> fitModel

let ff3Estimate_LONG = ff3Model_LONG |> fitModel
let ff3Estimate_LONGSHORT = ff3Model_LONGSHORT |> fitModel

capmEstimate_LONGSHORT.Model
ff3Estimate_LONGSHORT.Model

// Now let´s calulate R^2 for both models

let RsquaredCAPMLONGSHORT =r2Of capmEstimate_LONGSHORT.Model capmModel_LONGSHORT 
let RsquaredCAPMLONG =r2Of capmEstimate_LONG.Model capmModel_LONG 

let RsqauredFF3LONGSHORT=r2Of ff3Estimate_LONGSHORT.Model ff3Model_LONGSHORT
let RsqauredFF3LONG=r2Of ff3Estimate_LONG.Model ff3Model_LONG

(**
You will probably see that the CAPM $R^2$ is lower than the
Fama-French $R^2$. This means that you can explain more of the
portfolio's returns with the Fama-French model. Or in trader terms,
you can hedge the portfolio better with the multi-factor model.
We also want predicted values so that we can get regression residuals for calculating
the information ratio. ML.NET calls the predicted value the [score](https://docs.microsoft.com/en-us/dotnet/machine-learning/how-to-guides/machine-learning-model-predictions-ml-net).

The ML.NET OLS example shows getting predicted values using [C#](https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.mklcomponentscatalog.ols?view=ml-dotnet#Microsoft_ML_MklComponentsCatalog_Ols_Microsoft_ML_RegressionCatalog_RegressionTrainers_Microsoft_ML_Trainers_OlsTrainer_Options_) with the `context.Data.CreateEnumarable`. Searching the ML.NET samples github repo for `CreateEnumerable` shows [F#](https://github.com/dotnet/machinelearning-samples/search?l=F%23&q=createenumerable) examples.
*)
[<CLIMutable>]
type Prediction = { Label : float; Score : float}

let makePredictions (estimate:MultipleLinearRegression) (data:XY) =
    let x, y = data
    (estimate.Transform(x), y)
    ||> Array.zip
    |> Array.map(fun (score, label) -> { Score = score; Label = label })

let residuals (xs: Prediction array) = xs |> Array.map(fun x -> x.Label - x.Score)

let capmPredictions_LONGSHORT = makePredictions capmEstimate_LONGSHORT.Model capmModel_LONGSHORT
let capmPredictionsLONG = makePredictions capmEstimate_LONG.Model capmModel_LONG

let ff3Predictions_LONGSHORT = makePredictions ff3Estimate_LONGSHORT.Model ff3Model_LONGSHORT
let ff3Predictions_LONG = makePredictions ff3Estimate_LONG.Model ff3Model_LONG

let capmResidualsLONGSHORT = residuals capmPredictions_LONGSHORT
let capmResidualsLONG = residuals capmPredictionsLONG

let ff3ResidualsLONGSHORT = residuals ff3Predictions_LONGSHORT
let ff3ResidualsLONG = residuals ff3Predictions_LONG

// Now I am going to calculate the alphas, residual volatility and Information Ratio for both

let CAPMalphaLONG = 12.0 * capmEstimate_LONG.Model.Intercept 
let CAPMStDevResidualsLONG = sqrt(12.0) * (Seq.stDev capmResidualsLONG)
let CAPMInformationRatioLONG = CAPMalphaLONG / CAPMStDevResidualsLONG

let FF3alphaLONG = 12.0 * ff3Estimate_LONG.Model.Intercept 
let FF3StDevResidualsLONG = sqrt(12.0) * (Seq.stDev ff3ResidualsLONG)
let FF3InformationRatioLONG = FF3alphaLONG / FF3StDevResidualsLONG

let CAPMalphaLONGSHORT = 12.0 * capmEstimate_LONGSHORT.Model.Intercept 
let CAPMStDevResidualsLONGSHORT = sqrt(12.0) * (Seq.stDev capmResidualsLONGSHORT)
let CAPMInformationRatioLONGSHORT = CAPMalphaLONGSHORT / CAPMStDevResidualsLONGSHORT

let FF3alphaLONGSHORT = 12.0 * ff3Estimate_LONGSHORT.Model.Intercept 
let FF3StDevResidualsLONGSHORT = sqrt(12.0) * (Seq.stDev ff3ResidualsLONGSHORT)
let FF3InformationRatioLONGSHORT = FF3alphaLONGSHORT / FF3StDevResidualsLONGSHORT

//Now I want to create a table for both strategies

let LONGRegressHeader = ["CAPM-Alpha";"CAPM-SDRes";"CAPM-IR";"FF3-Alpha";"FF3-SDRes";"FF3-IR"]
let LONGRegressRow = 
    [     
     [ round 5 CAPMalphaLONG;round 5 CAPMStDevResidualsLONG;round 5 CAPMInformationRatioLONG; 
       round 5 FF3alphaLONG;round 5 FF3StDevResidualsLONG;round 5 FF3InformationRatioLONG ]        
    ]

let LONGRegresstats = Chart.Table(LONGRegressHeader, LONGRegressRow) 

LONGRegresstats|> Chart.withTitle "Long Regression statistics" |> Chart.Show



let RegressHeader = ["CAPM-Alpha";"CAPM-SDRes";"CAPM-IR";"FF3-Alpha";"FF3-SDRes";"FF3-IR"]
let RegressRow = 
    [     
     [ round 5 CAPMalphaLONGSHORT;round 5 CAPMStDevResidualsLONGSHORT;round 5 CAPMInformationRatioLONGSHORT; 
       round 5 FF3alphaLONGSHORT;round 5 FF3StDevResidualsLONGSHORT;round 5 FF3InformationRatioLONGSHORT; ]        
    ]

let Regresstats = Chart.Table(RegressHeader, RegressRow) 

Regresstats|> Chart.withTitle "Long-Short Regression statistics" |> Chart.Show




(**
# Portfolio Optimization

We're now going to see how to do mean-variance portfolio optimization.
The objective is to find the portfolio with the greatest return per
unit of standard deviation.

In particular, we're going to identify the tangency portfolio. 
The tangency portfolio is the portfolio fully invested 
in risky assets that has the maximum achievable sharpe ratio. 
When there is a risk-free rate, the efficient frontier 
of optimal portfolios is some combination of
the tangency portfolio and the risk-free asset. 
Investors who want safe portfolios hold a lot 
of bonds and very little of the tangency portfolio. 
Investors who want riskier portfolios hold little risk-free bonds and
a lot of the tangency portfolio (or even lever the tangency portoflio). 

Now one thing to keep in mind is that often you think 
of this as the optimal weight per security.
But one well known problem is that trying to do this naively does not work well.
And by naively I mean taking a stock's average return and covariances in the sample. 
In large part, this is because it is hard to estimate a stock's past returns.
I know. Big shock, right?

However, there are ways to do portfolio optimization that works better.
We can do it by creating large groups 
of stocks with similar characteristics. 
For example, a factor portfolio. 
Then you estimate the expected return and covariance matrix using the factor.
That tends to give you better portfolios 
because the characteristics that you're using 
to form the portfolios help you estimate 
the return and covariances of the stocks in it.
A type to hold our data.
*)
type StockData =
    { Symbol : string 
      Date : DateTime
      Return : float }
(**
We get the Fama-French 3-Factor asset pricing model data.
*)
//let ff3 = French.getFF3 Frequency.Monthly
// Transform to a StockData record type.
let ff3StockData =
    [| 
       ff3 |> Array.map(fun x -> {Symbol="HML";Date=x.Date;Return=x.Hml})
       ff3 |> Array.map(fun x -> {Symbol="MktRf";Date=x.Date;Return=x.MktRf})
       ff3 |> Array.map(fun x -> {Symbol="Smb";Date=x.Date;Return=x.Smb})
    |] |> Array.concat
(**
Let's get our factor data.
*)
let myFactorPorts = CsvProvider<"ReturnPortfolios.csv",
                                ResolutionFolder = __SOURCE_DIRECTORY__>.GetSample()

let long = 
    myFactorPorts.Rows 
    |> Seq.filter(fun row -> row.PortfolioName = "Mine" && row.Index = Some 1)
    |> Seq.map(fun x -> { Symbol = "Long"; Date = x.YearMonth; Return = x.Ret })
    |> Seq.toArray  

let short = 
    myFactorPorts.Rows 
    |> Seq.filter(fun row -> row.PortfolioName = "Mine" && row.Index = Some 3) 
    |> Seq.map(fun x -> { Symbol = "Short"; Date = x.YearMonth; Return = x.Ret })
    |> Seq.toArray  






























































let longshort =
    let shortMap = short |> Seq.map(fun row -> row.Date, row) |> Map
    long
    |> Seq.map(fun longObs -> 
        match Map.tryFind longObs.Date shortMap with
        | None -> failwith "probably your date variables are not aligned"
        | Some shortObs -> { Symbol = "LongShort"; Date = longObs.Date; Return = longObs.Return - shortObs.Return })
    |> Seq.toArray  
(**
Some good standard investments.
*)
let vti = 
    "VTI"
    |> Tiingo.request
    |> Tiingo.startOn (DateTime(2000,1,1))
    |> Tiingo.getReturns

let bnb = 
    "BND"
    |> Tiingo.request
    |> Tiingo.startOn (DateTime(2000,1,1))
    |> Tiingo.getReturns
(**
So let's combine the `VTI` and `BND` data, group by symbol and month,
and then convert to monthly returns.
*)
let standardInvestments =
    Array.concat [vti;bnb]
    |> Array.groupBy(fun x -> x.Symbol, x.Date.Year, x.Date.Month)
    |> Array.map(fun ((sym, year, month), xs) -> 
        let sortedRets = 
            xs
            |> Array.sortBy(fun x -> x.Date)
            |> Array.map(fun x -> x.Return)
        let monthlyGrossRet =
            (1.0, sortedRets)
            ||> Array.fold (fun acc x -> acc * (1.0 + x))
        { Symbol = sym
          Date = DateTime(year, month, 1)
          Return = monthlyGrossRet - 1.0 })
(**
And let's convert to excess returns
*)
let rf = ff3 |> Seq.map(fun x -> x.Date, x.Rf) |> Map

let standardInvestmentsExcess =
    let maxff3Date = ff3 |> Array.map(fun x -> x.Date) |> Array.max
    standardInvestments
    |> Array.filter(fun x -> x.Date <= maxff3Date)
    |> Array.map(fun x -> 
        match Map.tryFind x.Date rf with 
        | None -> failwith $"why isn't there a rf for {x.Date}"
        | Some rf -> { x with Return = x.Return - rf })
(**
If we did it right, the `VTI` return should be pretty similar to the `MktRF`
return from Ken French's website.
*)
standardInvestmentsExcess
|> Array.filter(fun x -> x.Symbol = "VTI" && x.Date.Year = 2021)
|> Array.map(fun x -> x.Date.Month, round 4 x.Return)
|> Array.take 3(* output: 
val it : (int * float) [] = [|(1, -0.0033); (2, 0.0314); (3, 0.0365)|]*)
ff3 
|> Array.filter(fun x -> x.Date.Year = 2021)
|> Array.map(fun x -> x.Date.Month, round 4 x.MktRf)(* output: 
val it : (int * float) [] = [|(1, -0.0003); (2, 0.0278); (3, 0.0309)|]*)
(**
Let's put our stocks in a map keyed by symbol
*)
let stockData long =
    Array.concat [| standardInvestmentsExcess; long |]
    |> Array.groupBy(fun x -> x.Symbol)
    |> Map

let symbols (x) = 
    x
    |> Map.toArray // convert to array of (symbol, observations for that symbol) 
    |> Array.map fst // take just the symbol
    |> Array.sort // sort them

let stock_Long =
    Array.concat [| standardInvestmentsExcess; long |]
    |> Array.groupBy(fun x -> x.Symbol)
    |> Map

let stock_LongShort =
    Array.concat [| standardInvestmentsExcess; longshort |]
    |> Array.groupBy(fun x -> x.Symbol)
    |> Map

let symbols_Long = 
    stock_Long 
    |> Map.toArray 
    |> Array.map fst 
    |> Array.sort

let symbols_LongShort = 
    stock_LongShort 
    |> Map.toArray 
    |> Array.map fst 
    |> Array.sort
(**
Let's create a function that calculates covariances
for two securities.
*)
let getCov x y stockData =
    let innerJoin xId yId =
        let xRet = Map.find xId stockData
        let yRet = Map.find yId stockData |> Array.map(fun x -> x.Date, x) |> Map
        xRet
        |> Array.choose(fun x ->
            match Map.tryFind x.Date yRet with
            | None -> None
            | Some y -> Some (x.Return, y.Return))
    let x, y = innerJoin x y |> Array.unzip
    Seq.cov x y

let covariances_Long =
    symbols_Long
    |> Array.map(fun x ->
        symbols_Long
        |> Array.map(fun y -> getCov x y stock_Long))
    |> matrix

let covariances_LongShort =
    symbols_LongShort
    |> Array.map(fun x ->
        symbols_LongShort
        |> Array.map(fun y -> getCov x y stock_LongShort))
    |> matrix

let Means_Long = 
    stock_Long
    |> Map.toArray
    |> Array.map(fun (sym, xs) ->
        sym,
        xs |> Array.averageBy(fun x -> x.Return))
    |> Array.sortBy fst
    |> Array.map snd
    |> vector

let Means_LongShort = 
    stock_LongShort
    |> Map.toArray
    |> Array.map(fun (sym, xs) ->
        sym,
        xs |> Array.averageBy(fun x -> x.Return))
    |> Array.sortBy fst
    |> Array.map snd
    |> vector

(**
This solution method for finding the tangency portfolio
comes from Hilliar, Grinblatt and Titman 2nd
European Edition, Example 5.3. 

Since it has the greatest possible Sharpe ratio, that means
that you cannot rebalance the portfolio and increase 
the return per unit of standard deviation.

The solution method relies on the fact that covariance
is like marginal variance. At the tangency portfolio,
it must be the case that the ratio of each asset's 
risk premium to it's covariance with the tangency portfolio, 
$(r_i-r_f)/cov(r_i,r_p)$, must be the same. Because that's
the return per marginal variance ratio, and if it was not
equal for all assets, then you could rebalance and increase the portfolio's 
return while holding the portfolio variance constant.

In the below algebra, we solve for the portfolio that has covariances with
each asset equal to the asset's risk premium. Then we relever to have a portfolio
weight equal to 1.0 (we can relever like this because everything is in excess returns)
and then we are left with the tangency portfolio.
*)
// solve A * x = b for x
let w' xs ys= Algebra.LinearAlgebra.SolveLinearSystem xs ys
let w xs ys = w' xs ys |> Vector.map ( fun x -> x / Vector.sum (w' xs ys ))

//calculating weights 

let w_LongEfficient= w covariances_Long Means_Long
let w_LongShortEfficient= w covariances_LongShort Means_LongShort
(*
for Long portfolio
*)
let AnnualizedPortfolio_StDev (xs:vector) (ys:matrix) =  sqrt(xs.Transpose * ys * xs)*sqrt(12.0)
let AnnualizedPortfolio_Mean (xs:vector) (ys:vector) = (xs.Transpose*ys)*(12.0)
let AnnualizedPortfolio_SharpeRatio (xs:vector) (ys:vector) (zs:matrix) = (AnnualizedPortfolio_Mean xs ys)/(AnnualizedPortfolio_StDev xs zs)

let Annualized_Long_Mean = AnnualizedPortfolio_Mean w_LongEfficient Means_Long
let Annualized_LongShort_Mean = AnnualizedPortfolio_Mean w_LongShortEfficient Means_LongShort

let Annualized_Long_StDev = AnnualizedPortfolio_StDev w_LongEfficient covariances_Long
let Annualized_LongShort_StDev = AnnualizedPortfolio_StDev w_LongShortEfficient covariances_LongShort

let Annaulized_Long_SharpeRatio = AnnualizedPortfolio_SharpeRatio w_LongEfficient Means_Long covariances_Long
let Annaulized_LongShort_SharpeRatio = AnnualizedPortfolio_SharpeRatio w_LongShortEfficient Means_LongShort covariances_LongShort

(*
creating a table with the output from long and Long and Short
*)
let long_header = ["LongStDev";"LongMean";"LongSR";"LS-Stdev";"LS-Mean";"LongShortSR"]
let long_rows = 
    [
     [ (round 5 Annualized_Long_StDev);(round 5 Annualized_Long_Mean);(round 5 Annaulized_Long_SharpeRatio); 
       ( round 5 Annualized_LongShort_StDev);(round 5 Annualized_LongShort_Mean); (round 5 Annaulized_LongShort_SharpeRatio)]        
    ]

let Eff_Portfolios = Chart.Table(long_header, long_rows) |> Chart.withTitle "Efficent Portfolios Statistics" |> Chart.Show
(*
3.3.2
creating a comparison portfolio 60 invested on VTI and 40 on BND
*)
let LONG_weights =
    Seq.zip symbols_Long w_LongEfficient
    |> Map.ofSeq

(**
symbol data grouped by date.
*)

let LONG_stockDataByDate =
    stock_Long 
    |> Map.toArray 
    |> Array.map snd 
    |> Array.collect id 
    |> Array.groupBy(fun x -> x.Date) 
    |> Array.sortBy fst 

let first_Month =
    LONG_stockDataByDate 
    |> Array.head 
    |> snd 

let last_Month =
    LONG_stockDataByDate 
    |> Array.last 
    |> snd 

let LONGallAssets_first =
    LONG_stockDataByDate
    |> Array.find(fun (month, stocks) -> stocks.Length = symbols_Long.Length)
    |> fst 

let LONGallAssets_End =
    LONG_stockDataByDate
    |> Array.findBack(fun (month, stocks) -> stocks.Length = symbols_Long.Length)
    |> fst 

let LONG_stockDataByDateComplete =
    LONG_stockDataByDate
    |> Array.filter(fun (date, stocks) -> 
        date >= LONGallAssets_first &&
        date <= LONGallAssets_End)


(**
 mve and 60/40 portfolios
*)

let LONG_testMonth =
    LONG_stockDataByDateComplete
    |> Array.find(fun (date, stocks) -> date = LONGallAssets_first)
    |> snd

let testBnd = LONG_testMonth |> Array.find(fun x -> x.Symbol = "BND")
let testVti = LONG_testMonth |> Array.find(fun x -> x.Symbol = "VTI")
let testLong = LONG_testMonth |> Array.find(fun x -> x.Symbol = "Long")

testBnd.Return*LONG_weights.["BND"] + testVti.Return*LONG_weights.["VTI"] + testLong.Return*LONG_weights.["Long"]


LONG_weights
|> Map.toArray
|> Array.map(fun (symbol, weight) ->
    let symbolData = LONG_testMonth |> Array.find(fun x -> x.Symbol = symbol)
    symbolData.Return*weight)
|> Array.sum   


let portfolioMonthReturn w monthData =
    w
    |> Map.toArray
    |> Array.map(fun (symbol, weight) ->
        let symbolData = 
            match monthData |> Array.tryFind(fun x -> x.Symbol = symbol) with
            | None -> failwith $"You tried to find {symbol} in the data but it was not there"
            | Some data -> data
        symbolData.Return*weight)
    |> Array.sum    
    
portfolioMonthReturn LONG_weights LONG_testMonth

(**
Here's a thought. We just made a function that takes
weights and a month as input. That means that it should
work if we give it different weights.
Let's try to give it 60/40 weights.
*)

let weights6040 = Map [("VTI",0.6);("BND",0.4)]

weights6040.["VTI"]*testVti.Return +
weights6040.["BND"]*testBnd.Return

portfolioMonthReturn weights6040 LONG_testMonth


let LONGportMve =
    LONG_stockDataByDateComplete
    |> Array.map(fun (date, data) -> 
        { Symbol = "Long Only MVE"
          Date = date
          Return = portfolioMonthReturn LONG_weights data })

let LONGSHORTportMve =
    LONG_stockDataByDateComplete
    |> Array.map(fun (date, data) -> 
        { Symbol = "Long Only MVE"
          Date = date
          Return = portfolioMonthReturn LONG_weights data })

let port6040 = 
    LONG_stockDataByDateComplete
    |> Array.map(fun (date, data) -> 
        { Symbol = "60/40"
          Date = date 
          Return = portfolioMonthReturn weights6040 data} )

(**
It is nice to plot cumulative returns.

A function to accumulate returns.
*)

let cumulateReturns xs =
    let mapFolder prevRet x =
        let newReturn = prevRet * (1.0+x.Return)
        { x with Return = newReturn}, newReturn
    
    (1.0, xs) 
    ||> Array.mapFold mapFolder
    |> fst    
(**
Ok, cumulative returns.
*)

let portMveCumulative = 
    LONGportMve
    |> cumulateReturns

let port6040Cumulative = 
    port6040
    |> cumulateReturns

let LONGchartMVE = 
    portMveCumulative
    |> Array.map(fun x -> x.Date, x.Return)
    |> Chart.Line
    |> Chart.withTraceName "Long Only MVE"

let chart6040 = 
    port6040Cumulative
    |> Array.map(fun x -> x.Date, x.Return)
    |> Chart.Line
    |> Chart.withTraceName "60/40"

let chartCombined =
    [| LONGchartMVE; chart6040 |]
    |> Chart.Combine
    |> Chart.withTitle "Efficient Portfolio without Volatility Target"
    |> Chart.Show

(**
Those are partly going to differ because they have different volatilities.
It we want to have a sense for which is better per unit of volatility,
then it can make sense to normalize volatilities.
First compare the MVE vol
*)

let LONGportMveVol=
    LONGportMve
    |> Array.map(fun x -> x.Return)
    |> Seq.stDev
    |> fun vol -> sqrt(12.0) * vol

(* output: 
0.04081523203*)
(**
To the 60/40 vol.
*)

let port6040Vol=
    port6040
    |> Array.map(fun x -> x.Return)
    |> Seq.stDev
    |> fun vol -> sqrt(12.0)*vol


(* output: 
0.09986539511*)
(**
Ok, cumulative returns of the normalized vol returns.
*)

let normalize10pctVol xs =
    let vol = xs |> Array.map(fun x -> x.Return) |> Seq.stDev
    let annualizedVol = vol * sqrt(12.0)
    xs 
    |> Array.map(fun x -> { x with Return = x.Return * (0.1/annualizedVol)})

let LONGportMveCumulativeNormlizedVol = 
    LONGportMve
    |> normalize10pctVol
    |> cumulateReturns

normalizeToTenPct

let port6040CumulativeNormlizedVol = 
    port6040
    |> normalize10pctVol 
    |> cumulateReturns


let LONGchartMVENormlizedVol = 
    LONGportMveCumulativeNormlizedVol
    |> Array.map(fun x -> x.Date, x.Return)
    |> Chart.Line
    |> Chart.withTraceName "LONG Only MVE"

let chart6040NormlizedVol = 
    port6040CumulativeNormlizedVol
    |> Array.map(fun x -> x.Date, x.Return)
    |> Chart.Line
    |> Chart.withTraceName "60/40"

let chartCombinedNormlizedVol =
    [| LONGchartMVENormlizedVol; chart6040NormlizedVol |]
    |> Chart.Combine
chartCombinedNormlizedVol |> Chart.Show


(**
## Key points to keep in mind.
The mean-variance efficient portfolio will always look best in the sample period 
in which you estimated the weights.
This is because we found it by literally looking for the portfolio 
with the highest sharpe ratio in that sample.

A more meaningful comparison would be to estimate mean-variance efficient weights based
on past data and see how those weights perform in future data. 
For instance, estimate weights 2000-2010, and use those weights to determine
the portfolio that you're going to hold in 2011.
Finally, compare it to 60/40 in 2011.
That is an "out of sample" test because your test period (2011) 
is different from the period when the weights were estimated (2000-2010).
Then repeat, always using data *before* the holding period as your training period
to estimate the weights for the test holding period. 

It is also important to remember that 10-20 years is not long enough 
to get a good estimate of a portfolio's expected return. 

One way to see this is to compare equity returns 2000-2010 and 2010-2020.
*)

let pastMktRfReturns=
    ff3
    |> Seq.filter(fun x -> 
        x.Date >= DateTime(2000,1,1) &&
        x.Date <= DateTime(2009,12,31))
    |> Seq.averageBy(fun x ->
        12.0*x.MktRf)

let pastMktRfVol=
    ff3
    |> Seq.filter(fun x -> 
        x.Date >= DateTime(2000,1,1) &&
        x.Date <= DateTime(2009,12,31))
    |> Seq.stDevBy(fun x ->
        sqrt(12.0)*x.MktRf)

let FutureMktRfReturns=
    ff3
    |> Seq.filter(fun x -> 
        x.Date >= DateTime(2010,1,1) &&
        x.Date <= DateTime(2019,12,31))
    |> Seq.averageBy(fun x ->
        12.0*x.MktRf)

let FutureMktRfVol=
    ff3
    |> Seq.filter(fun x -> 
        x.Date >= DateTime(2010,1,1) &&
        x.Date <= DateTime(2019,12,31))
    |> Seq.stDevBy(fun x ->
        sqrt(12.0)*x.MktRf)

let GapbetweenPastandFutureRet = abs (pastMktRfReturns-FutureMktRfReturns)
let GapbetweenPastandFutureVol = abs (pastMktRfVol-FutureMktRfVol)

(**
Neither of those 10-year periods is a good estimate of expected market returns.
Thus it does not make sense to try forming a mean-variance efficient portfolio
using the trailing 10-year period for estimating forward-looking returns.
If we look at US returns 1900-2012, the data indicates that equity excess returns
were about 5.5%, and bond excess returns were about 1%. 
Covariances over shorter periods are more reasonable,
so we can use the recent sample to estimate covariances and the long sample for means.
*)

let symStockBond = [|"VTI";"BND"|]
let covStockBond =
    symStockBond
    |> Array.map(fun x ->
        symStockBond
        |> Array.map(fun y -> getCov x y stock_Long))
    |> matrix
let meansStockBond = Vector.ofArray [| 0.055/12.0; 0.01/12.0|]

let wStockBond =
    let w' = Algebra.LinearAlgebra.SolveLinearSystem covStockBond meansStockBond
    w' |> Vector.map(fun x -> x /  Vector.sum w')

wStockBond 

let stockBondSharpeAndSD (weights:float Vector) =
    let sbVar = weights.Transpose * covStockBond * weights
    let sbStDev = sqrt(12.0)*sqrt(sbVar)
    let sbMean = 12.0 * (weights.Transpose * meansStockBond)
    let sbSharpeRatio = (sbMean/sbStDev)
    sbSharpeRatio, sbStDev


stockBondSharpeAndSD wStockBond

stockBondSharpeAndSD (Vector.ofArray [|0.6;0.4|])


